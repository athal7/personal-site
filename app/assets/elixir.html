<!DOCTYPE html>
<html>
  <head>
    <title>Introduction to Elixir</title>
    <meta charset="utf-8">
  </head>
  <body>
    <textarea id="source">
      class: center, middle
      ## Introduction to Elixir
      Andrew Thal, 2U
      ---
      # Our goals:
      1. Learn about Elixir
      2. Talk a little bit about Erlang
      3. Build a live quiz together to learn Phoenix
      ---
      ### But first
      
      Since internet speeds are questionable...
      
      ```bash
      brew install elixir
      mix local.hex
      mix archive.install https://github.com/phoenixframework/archives/raw/master/phoenix_new.ez
      brew install postgresql # and follow post-install instructions
      createuser -s postgres # maybe
      ```
      ---
      class: center, middle
      ![elixir](http://a.pragprog.com/magazines/2013-07/images/elixir-flame__1uaywq__.png)
      
      [elixir-lang.org](http://elixir-lang.org)
      ---
      class: middle
      ### "Elixir is a dynamic, functional language designed for building scalable and maintainable applications."
      [elixir-lang.org](http://elixir-lang.org)
      ---
      class: middle
      ### "Elixir leverages the Erlang VM, known for running low-latency, distributed and fault-tolerant systems, while also being successfully used in web development and the embedded software domain."
      [elixir-lang.org](http://elixir-lang.org)
      ---
      class: middle
      ### "I downloaded elixir last week and started playing ...It didn't take long, but pretty soon my gut feeling kicked in. This is good shit."
      [Joe Armstrong, co-creator of Erlang](http://joearms.github.io/2013/05/31/a-week-with-elixir.html)
      ---
      class: middle
      ### "Maybe you need something that’s closer to Ruby, but with a battle-proven environment that’s unrivaled for massive scalability, concurrency, distribution, and fault tolerance. Maybe the time is right for the Next Big Thing. Maybe it’s Elixir."
      [Dave Thomas, Pragmatic Bookshelf](https://pragprog.com/book/elixir/programming-elixir)
      ---
      ## Elixir
      * Inspired by Bruce Tate's [Seven Languages in Seven Weeks](https://pragprog.com/book/btlang/seven-languages-in-seven-weeks)
      * Created by Jose Valim in 2011 (originally called Lego)
      * Used in production by Pinterest, Bleacher Report, WhatsApp (Erlang)
      * Functional language, but approachable from an object-oriented background
      * QWAN: [Presentation by Dave Thomas & Bruce Tate](https://www.youtube.com/watch?v=fklep3sUSWo)
      ---
      ## Elixir
      1. Scalability
      2. Maintainability
      3. Expressiveness
      ---
      class: center, middle
      # Elixir |> Scalability
      ---
      ## Elixir |> Scalability
      * BEAM
      * 2MM TCP connections per server:
        * [WhatsApp](https://blog.whatsapp.com/196/1-million-is-so-2011)
        * [Phoenix testing on Rackspace](http://www.phoenixframework.org/blog/the-road-to-2-million-websocket-connections)
      * Compiles to idiomatic erlang
      * Safe concurrency w/ immutability
      ---
      ## Elixir |> Scalability
      ### With Phoenix
      * Sub-millisecond response times
        * Average django app response time is ~ 100ms
      * Tiny memory footprint (live quiz app is < 30MB)
        * Average rails app consumes ~ 1GB, with 50% of execution time in GC
      ---
      class: center, middle
      # Elixir |> Maintainability
      ---
      ## Elixir |> Maintainability
      "Erlang is used all over the world in high-tech projects where reliability counts. The Erlang flagship project (built by Ericsson, the Swedish telecom company) is the AXD301. This has over 2 million lines of Erlang.
      
      The AXD301 has achieved a NINE nines reliability (yes, you read that right, 99.9999999%). Let’s put this in context: 5 nines is reckoned to be good (5.2 minutes of downtime/year). 7 nines almost unachievable ... but we did 9.
      
      Why is this? No shared state, plus a sophisticated error recovery model."
      
      [https://pragprog.com/articles/erlang](https://pragprog.com/articles/erlang)
      ---
      ## Elixir |> Maintainability
      
      Inherited from Erlang
      * OTP/Distributed communication
      * Observer
      * Process snapshots on error
      * Hot reload code *within* a request
      * Time-tested Erlang libraries
      ---
      ## Elixir |> Maintainability
      
      Functional Programming
      * Immutability & explicitness
      * Separating data from code
      * No implicit state, destructive mutations, or unknown 'side effects'
      * [Good blog post by Plataformatec](http://blog.plataformatec.com.br/2016/05/beyond-functional-programming-with-elixir-and-erlang)
      ---
      ## Elixir |> Maintainability
      
      Elixir-specific
      * Fast & helpful compiler
      * Doctests & Typespecs
      * Syntax / Expressiveness
      * Other tooling (esp. for web)
      ---
      class: center, middle
      # Elixir |> Expressiveness
      ---
      ## Elixir |> Expressiveness
      Pipelines
      ```elixir
      iex> Enum.sum(Enum.filter(Enum.map(1..100_000, &(&1 * 3)), odd?))
      7500000000
      ```
      becomes
      ```elixir
      iex> 1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(odd?) |> Enum.sum
      7500000000
      ```
      ---
      ## Elixir |> Expressiveness
      Pattern matching
      ```elixir
      iex> {a, b, c} = {:hello, "world", 42}
      {:hello, "world", 42}
      iex> a
      :hello
      iex> b
      "world"
      ```
      ```elixir
      iex> [head | tail] = [1, 2, 3]
      [1, 2, 3]
      iex> head
      1
      iex> tail
      [2, 3]
      ```
      ---
      ## Elixir |> Expressiveness
      Pattern matching
      ```elixir
      def hello("2tor") do
        hello("2U")
      end
      
      def hello(name) do
        "Hello #{name}!"
      end
      
      hello("2tor")
      #=> "Hello 2U!"
      
      hello("Andrew")
      #=> "Hello Andrew!"
      ```
      ---
      ## Elixir |> Expressiveness
      Function arity
      
      In both Erlang and Elixir, a function is not identified only by its name, but by its name and arity
      ```elixir
      def hello do
        hello("World")
      end
      
      def hello(name) do
        "Hello #{name}!"
      end
      
      hello
      #=> "Hello World!"
      
      hello("Andrew")
      #=> "Hello Andrew!"
      ```
      ---
      ## Elixir |> Expressiveness
      Put it all together
      
      ```elixir
      def count(l), do: count(l, 0)
      
      defp count([], accum), do: accum
      defp count([_head|tail], accum), do: count(tail, accum + 1)
      
      count([1,3,5,7])
      #=> 4
      ```
      ---
      ## Elixir |> Expressiveness
      All of this helps increase development efficiencies by reducing:
      - branching code / conditionals
      - missed edgecases
      - bugs caused by implicit state assumptions!
      ---
      class: center, middle
      # Live Quiz!
      #### Questions before we get started?
      ---
      ## Live Quiz |> Initial Setup
      Install Dependencies (we already did this)
      
      ```bash
      brew install elixir
      mix local.hex
      mix archive.install https://github.com/phoenixframework/archives/raw/master/phoenix_new.ez
      brew install postgresql # and follow post-install instructions
      createuser -s postgres # maybe
      ```
      ---
      ## Live Quiz |> Initial Setup
      Create & Boot the app
      
      ```bash
      mix phoenix.new live_quiz # create the app
      cd live_quiz
      mix ecto.create # create the database
      mix phoenix.server # start the server
      open http://localhost:4000
      ```
      ---
      class: center, middle
      # Live Quiz |> Modeling
      ---
      ## Live Quiz |> Modeling
      ```bash
      mix phoenix.gen.html Question questions prompt answer # kind of like 'rails g scaffold'
      mix phoenix.gen.model Answer answers question_id:references:questions response user
      ```
      Take a look at what was generated—we even get tests!
      
      For default answer serialization, in `web/models/answer.ex`, add:
      ```elixir
      @derive {Poison.Encoder, only: [:response, :user, :question_id]}
      schema "answers" do
      ...
      ```
      
      ---
      ## Live Quiz |> Modeling
      In `web/router.ex`:
      ```elixir
      resources "/questions", QuestionController` inside `scope "/"`
      ```
      
      In a shell:
      ```bash
      mix ecto.migrate
      open http://localhost:4000/questions # create some questions!
      ```
      
      Take a look at the response times in the logs, you might see `µs`, as in 'micro-seconds' :)
      ---
      class: center, middle
      # Live Quiz |> Quiz UI
      ---
      ## Live Quiz |> Quiz UI
      
      Visit [http://localhost:4000]() again so we can watch everything live-update as we make changes
      
      In `web/router.ex` change `get "/"` to:
      
      ```elixir
      get "/", QuestionController, :quiz
      ```
      ---
      ## Live Quiz |> Quiz UI
      Create the quiz action in `web/controllers/question_controller.ex`:
      ```elixir
      ...
      
      def quiz(conn, _params) do
        questions = Repo.all(Question)
        render(conn, "quiz.html", questions: questions)
      end
      ```
      ---
      ## Live Quiz |> Quiz UI
      Create `web/templates/question/quiz.html.eex`:
      ```html
      <h2>Quiz</h2>
      
      <h3>Name: <input id='user-name' type='text' /></h3>
      
      <table class="table">
        <thead>
          <tr>
            <th>Prompt</th>
            <th>My Answer</th>
            <th>Other Answers</th>
          </tr>
        </thead>
        <tbody>
        <%= for question <- @questions do %>
            <tr question-id='<%= question.id %>' id="question-<%= question.id %>" class='question'>
              <td class='quiz-prompt'><%= question.prompt %></td>
              <td class='quiz-answer'><input type=text /> <button>Submit</button></td>
              <td class='quiz-other-answers'></td>
            </tr>
        <% end %>
        </tbody>
      </table>
      ```
      ---
      class: middle
      # Live Quiz |> Interaction
      Phoenix gives us channels to communicate between browser sessions.
      We won't spend too much time on the javascript implementation here, since that's not the purpose of this exercise.
      ---
      ## Live Quiz |> Interaction
      In `web/static/js/app.js`
      ```js
      import socket from "./socket"
      
      let answers = {}
      
      function user() {
        return document.querySelector("#user-name").value
      }
      
      function addAnswer(questionId, user, answer) {
        if(!answers[questionId]) { answers[questionId] = {} }
        answers[questionId][user] = answer
        renderAnswers()
      }
      
      function renderAnswers() {
        const currentUser = user()
        for (let questionId in answers) {
          let answerArea = document.querySelector(`#question-${questionId} .quiz-other-answers`)
          answerArea.innerHTML = ''
          let responses = answers[questionId]
          for (let user in responses) {
            if (user != currentUser) {
              let otherAnswer = document.createElement('div')
              otherAnswer.innerHTML = `${user}: ${responses[user]}`
              answerArea.appendChild(otherAnswer)
            }
          }
        }
      }
      ...
      ```
      ---
      ## Live Quiz |> Interaction
      In `web/static/js/app.js`
      ```js
      ...
      let quizChannel = socket.channel("quiz:lobby")
      
      quizChannel.join()
        .receive("ok", () => { console.log("Joined quiz channel!") })
        .receive("error", () => { console.log("Unable to join quiz channel") })
      
      quizChannel.on("answer", answer => {
        if (answer.user != user()) {
          addAnswer(answer.question_id, answer.user, answer.response)
        }
      })
      
      const answerButtons = document.querySelectorAll(".quiz-answer > button")
      for (let i=0; i < answerButtons.length; i++) {
        let questionId = answerButtons[i].closest(".question").attributes["question-id"].value
        answerButtons[i].addEventListener('click', (event) => {
          let response = document.querySelector(`#question-${questionId} input`).value
          quizChannel.push("answer", { answer: response, question_id: questionId, user: user() })
            .receive("ok", (payload) => {
              for (let answer of payload.answers) {
                addAnswer(payload.question_id, answer.user, answer.response)
              }
            })
            .receive("error", (payload) => { console.error(payload) })
        })
      }
      ```
      ---
      class: center, middle
      # Live Quiz |> Channels
      And now for the phoenix channels fun!
      ---
      ## Live Quiz |> Channels
      In a shell:
      ```bash
      mix phoenix.gen.channel Quiz
      ```
      
      In `web/channels/user_socket.ex`:
      ```elixir
      defmodule LiveQuiz.UserSocket do
        use Phoenix.Socket
      
        channel "quiz:lobby", LiveQuiz.QuizChannel
        ...
      ```
      ---
      ## Live Quiz |> Channels
      ```elixir
      ...
      alias LiveQuiz.Answer
      
      def handle_in("answer", %{"answer" => response, "question_id" => question_id, "user" => user}, socket) do
        question_id = String.to_integer(question_id)
        params = %{question_id: question_id, user: user}
      
        (Repo.get_by(Answer, params) || struct(Answer, params))
        |> Answer.changeset(%{response: response})
        |> Repo.insert_or_update
        |> handle_answer_upsert(socket)
      end
      
      def handle_answer_upsert({:ok, answer}, socket) do
        broadcast socket, "answer", answer
      
        response = %{
          question_id: answer.question_id,
          answers: all_answers(answer.question_id)
        }
        {:reply, {:ok, response}, socket}
      end
      
      def handle_answer_upsert({:error, changeset}, socket) do
        {:reply, {:error, changeset.errors}, socket}
      end
      
      def handle_answer_upsert(error, _socket), do: raise(error)
      
      defp all_answers(question_id) do
        Repo.all(from a in Answer, where: a.question_id == ^question_id)
      end
      ...
      ```
      ---
      # Live Quiz
      Visit [localhost:4000](http://localhost:4000) in two tabs/windows, and you should see the responses live update on the other tab!
      ---
      ## Live Quiz |> Homework
      This quiz is fine for beginners, but the user probably wants to know whether their answer is correct.
      
      Let's see if you can give the user feedback about the correctness of their response.
      
      The [Phoenix Docs](https://hexdocs.pm/phoenix/Phoenix.html) will be your friend.
      
      Pull requests to [my repo](https://github.com/athal7/elixir_learning) with your solutions are encouraged!
      ---
      ## Elixir |> Learning Resources
      If you agree with Dave Thomas and think Elixir has QWAN, here are some resources you might like:
      
      Documentation
      * [elixir-lang.org](http://elixir-lang.org)
      * [phoenixframework.org](http://phoenixframework.org)
      
      Books
      * [Programming Elixir](https://pragprog.com/book/elixir12/programming-elixir-1-2)
      * [Programming Phoenix](https://pragprog.com/book/phoenix/programming-phoenix)
      * [Metaprogramming Elixir](https://pragprog.com/book/cmelixir/metaprogramming-elixir)
      * [Seven More Languages in Seven Weeks](https://pragprog.com/book/7lang/seven-more-languages-in-seven-weeks)
      
      ---
      ## Elixir |> Learning Resources
      
      Practice
      * [Exercism](http://exercism.io/)
      * [Elixir Golf](http://elixirgolf.com/about/)
      * [Advent of Code](http://adventofcode.com/)
      
      Conferences
      * [ElixirConf](http://www.elixirconf.com/#) - August 2016 Orlando, FL
      * [OpenCamps](http://opencamps.org/) -  July 15-17 NYC $20
      
      ---
      ## Elixir |> Learning Resources
      
      Other
      * *[Changelog Podcast w/ José Valim](https://changelog.com/194/)*
      * [Elixir Radar newsletter](http://plataformatec.com.br/elixir-radar)
      * [Elixir Sips podcast](http://elixirsips.com/)
      * [Elixir Fountain podcast](https://soundcloud.com/elixirfountain)
      * [ExCasts podcast](https://excasts.com/)
      * [List of Talks](https://github.com/elixir-lang/elixir/wiki/Talks)
      ---
      class: middle
      ## Introduction to Elixir
      #### Thank you for your time! Questions?
    </textarea>
    <link rel="stylesheet" type="text/css" href="./remark.css"></link>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
    <script src="./remark.js"></script>

    <style>
      @import url(https://fonts.googleapis.com/css?family=Bitter);
      body { font-family: 'Bitter'; }
      h1, h2, h3, a {
        color: #4E2A8E;
      }
    </style>
  </body>
</html>
